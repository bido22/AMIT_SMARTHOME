/*
 * TMR_Program.c
 *
 * Created: 10/6/2022 4:45:01 PM
 *  Author: Marwan Yasser
 */ 

#include "../bitmath.h"
#include "../ATMEGA32_REG.h"
#include "../STD_types.h"

#include "TMR_Config.h"
#include "TMR_Interface.h"


/* TIMER 0 */
void TMR_timer0SetClock()
{
	SET_BIT(DDRB, 3);
	#if TMR_TIMER0_PRESCALAR_VALUE == TMR_CLOCK_OFF
	CLR_BIT(TCCR0, 2);
	CLR_BIT(TCCR0, 1);
	CLR_BIT(TCCR0, 0);
	#elif TMR_TIMER0_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_1
	CLR_BIT(TCCR0, 2);
	CLR_BIT(TCCR0, 1);
	SET_BIT(TCCR0, 0);
	#elif TMR_TIMER0_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_8
	CLR_BIT(TCCR0, 2);
	SET_BIT(TCCR0, 1);
	CLR_BIT(TCCR0, 0);
	#elif TMR_TIMER0_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_64
	CLR_BIT(TCCR0, 2);
	SET_BIT(TCCR0, 1);
	SET_BIT(TCCR0, 0);
	#elif TMR_TIMER0_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_256
	SET_BIT(TCCR0, 2);
	CLR_BIT(TCCR0, 1);
	CLR_BIT(TCCR0, 0);
	#elif TMR_TIMER0_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_1024
	SET_BIT(TCCR0, 2);
	CLR_BIT(TCCR0, 1);
	SET_BIT(TCCR0, 0);
	#elif TMR_TIMER0_PRESCALAR_VALUE == TMR_CLOCK_EXT_FALLING_EDGE
	SET_BIT(TCCR0, 2);
	SET_BIT(TCCR0, 1);
	CLR_BIT(TCCR0, 0);
	#elif TMR_TIMER0_PRESCALAR_VALUE == TMR_CLOCK_EXT_RISING_EDGE
	SET_BIT(TCCR0, 2);
	SET_BIT(TCCR0, 1);
	SET_BIT(TCCR0, 0);
	#endif
}
void TMR_timer0Init()
{
	#if TMR_TIMER0_OPERATING_MODE == TMR_TIMER0_NORMAL_MODE || TMR_TIMER0_OPERATING_MODE == TMR_TIMER0_CTC_MODE
		SET_BIT(TIMSK, 0);
	#endif
	TCCR0 &= 0b10000111;
	TCCR0 |= TMR_TIMER0_OPERATING_MODE;
}
#if TMR_TIMER0_OPERATING_MODE == TMR_TIMER0_FAST_PWM_MODE || TMR_TIMER0_OPERATING_MODE == TMR_TIMER0_PHASE_CORRECT_PWM_MODE
	void TMR_setPWM0(u8 TMR_timer0_PWM_dutyCycle){
		if(!(TCCR0 % 8))
			TMR_timer0Init();
		OCR0 = (u32)TMR_timer0_PWM_dutyCycle * 1023 / 100;
		TMR_timer0SetClock();
	}
	void TMR_stopPWM0(){
		TCCR0 &= 0b11111000;
	}
#endif

void TMR_setTimer(u32 desiredTime, u32* number_of_flags)
{
	
	#if TMR_TIMER0_OPERATING_MODE == TMR_TIMER0_NORMAL_MODE
	*number_of_flags = 1 + desiredTime * 1000 / (16 *  TMR_TIMER0_PRESCALAR_VALUE);
	TCNT0 = 256 - ((desiredTime * 1000) % (16 *  TMR_TIMER0_PRESCALAR_VALUE)) / 4;
	
	#elif TMR_TIMER0_OPERATING_MODE == TMR_TIMER0_CTC_MODE
	u32 number_of_ticks = desiredTime * 10000000 / (625 * TMR_TIMER0_PRESCALAR_VALUE);
	u8 i = 255;
	while(i >= 0 && number_of_ticks % (i + 1))
		i--;
			
	OCR0 = i;
	*number_of_flags = number_of_ticks / (i + 1);
	#endif
	if(!(TCCR0 % 8)){
		TMR_timer0Init();
		TMR_timer0SetClock();
	}
}
void TMR_stopTimer(){
	TCCR0 &= 0b11111000;
}

/* TIMER 1 */
void TMR_timer1Init()
{
	#if TMR_TIMER1_OPERATING_MODE == TMR_TIMER1_NORMAL_MODE
	CLR_BIT(TCCR1B, 4);
	CLR_BIT(TCCR1B, 3);
	CLR_BIT(TCCR1A, 1);
	CLR_BIT(TCCR1A, 0);

	#elif TMR_TIMER1_OPERATING_MODE == TMR_TIMER1_CTC_MODE
	CLR_BIT(TCCR1B, 4);
	SET_BIT(TCCR1B, 3);
	CLR_BIT(TCCR1A, 1);
	CLR_BIT(TCCR1A, 0);
	
	#elif TMR_TIMER1_OPERATING_MODE == TMR_TIMER1_ICR_FAST_PWM_MODE
	SET_BIT(TCCR1B, 4);
	SET_BIT(TCCR1B, 3);
	SET_BIT(TCCR1A, 1);
	CLR_BIT(TCCR1A, 0);
	
	SET_BIT(TCCR1A, 7);
	CLR_BIT(TCCR1A, 6);
	
	#endif
}
void TMR_timer1SetClock()
{
	#if TMR_TIMER1_PRESCALAR_VALUE == TMR_CLOCK_OFF
	CLR_BIT(TCCR1B, 2);
	CLR_BIT(TCCR1B, 1);
	CLR_BIT(TCCR1B, 0);
	#elif TMR_TIMER1_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_1
	CLR_BIT(TCCR1B, 2);
	CLR_BIT(TCCR1B, 1);
	SET_BIT(TCCR1B, 0);
	#elif TMR_TIMER1_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_8
	CLR_BIT(TCCR1B, 2);
	SET_BIT(TCCR1B, 1);
	CLR_BIT(TCCR1B, 0);
	#elif TMR_TIMER1_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_64
	CLR_BIT(TCCR1B, 2);
	SET_BIT(TCCR1B, 1);
	SET_BIT(TCCR1B, 0);
	#elif TMR_TIMER1_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_256
	SET_BIT(TCCR1B, 2);
	CLR_BIT(TCCR1B, 1);
	CLR_BIT(TCCR1B, 0);
	#elif TMR_TIMER1_PRESCALAR_VALUE == TMR_CLOCK_PRESCALAR_1024
	SET_BIT(TCCR1B, 2);
	CLR_BIT(TCCR1B, 1);
	SET_BIT(TCCR1B, 0);
	#elif TMR_TIMER1_PRESCALAR_VALUE == TMR_CLOCK_EXT_FALLING_EDGE
	SET_BIT(TCCR1B, 2);
	SET_BIT(TCCR1B, 1);
	CLR_BIT(TCCR1B, 0);
	#elif TMR_TIMER1_PRESCALAR_VALUE == TMR_CLOCK_EXT_RISING_EDGE
	SET_BIT(TCCR1B, 2);
	SET_BIT(TCCR1B, 1);
	SET_BIT(TCCR1B, 0);
	#endif
}
void TMR_setPWM(u32 TMR_timer1_PWM_frequency, u8 TMR_timer1_PWM_dutyCycle)
{
	if(TMR_timer1_PWM_frequency < 244 / TMR_TIMER1_PRESCALAR_VALUE || TMR_timer1_PWM_frequency > F_CPU / TMR_TIMER1_PRESCALAR_VALUE)
		return;
		
	SET_BIT(DDRD, 5);
	
	TMR_timer1_PWM_dutyCycle = (TMR_timer1_PWM_dutyCycle > 100)? 100 : TMR_timer1_PWM_dutyCycle;
	ICR1 = F_CPU / (TMR_timer1_PWM_frequency * TMR_TIMER1_PRESCALAR_VALUE) - 1;
	//OCR1A = (100UL * ICR1 - TMR_timer1_PWM_dutyCycle * (ICR1 + 1)) / 100;
	OCR1A = TMR_timer1_PWM_dutyCycle * (u32)(ICR1 + 1) / 100;
	if(!(TCCR1B % 8)){
		TMR_timer1Init();
		TMR_timer1SetClock();
	}
}
void TMR_stopPWM(){
	TCCR1B &= 0b11111000;
}
